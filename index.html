<!doctype html>

<html lang="en">
    
    <head>
        <meta charset="utf-8">

        <title>kianjones.com - Infrastructure Engineer</title>
        <meta name="description" content="Kian Jones - Infrastructure Engineer @ Letta, building systems for AI agents">
        
        <link rel="stylesheet" href="style.css">
        
    </head>
    
    <body>
        
        <div class="ide-container">
            <!-- Title Bar -->
            <div class="title-bar">
                <div class="title-bar-left">
                    <span class="window-controls">
                        <span class="control close"></span>
                        <span class="control minimize"></span>
                        <span class="control maximize"></span>
                    </span>
                    <span class="app-title">kianjones.com - VS Code</span>
                </div>
                <div class="title-bar-center">README.md</div>
                <div class="title-bar-right">
                    <div class="theme-switcher-container">
                        <button id="theme-switcher" class="theme-button">üé®</button>
                        <div id="theme-dropdown" class="theme-dropdown">
                            <div class="theme-option" data-theme="0">üü£ Purple</div>
                            <div class="theme-option" data-theme="1">üü† Orange</div>
                            <div class="theme-option" data-theme="2">üü¢ Green</div>
                            <div class="theme-option" data-theme="3">üî¥ Red</div>
                            <div class="theme-option" data-theme="4">üîµ Cyan</div>
                            <div class="theme-option" data-theme="5">üü° Yellow</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main IDE Layout -->
            <div class="ide-main">
                <!-- Sidebar -->
                <div class="sidebar">
                    <div class="sidebar-header">
                        <div class="sidebar-title">EXPLORER</div>
                    </div>
                    <div class="file-tree">
                        <div class="folder open">
                            <div class="folder-header" onclick="toggleFolder(this)">
                                <span class="folder-icon">üìÅ</span>
                                <span class="folder-name">kianjones.com</span>
                            </div>
                            <div class="folder-content">
                                <div class="file active" onclick="document.querySelectorAll('.file').forEach(f => f.classList.remove('active')); this.classList.add('active'); loadFile('readme')">
                                    <span class="file-icon">üìÑ</span>
                                    <span class="file-name">README.md</span>
                                </div>
                                <div class="folder">
                                    <div class="folder-header" onclick="toggleFolder(this)">
                                        <span class="folder-icon">üìÅ</span>
                                        <span class="folder-name">posts/</span>
                                    </div>
                                    <div class="folder-content" id="posts-folder-content">
                                        <!-- Posts will be loaded dynamically -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar Resize Handle -->
                <div class="resize-handle sidebar-resize"></div>

                <!-- Content Area -->
                <div class="content-area">
                    <div class="tab-bar">
                        <div class="tab active">
                            <span class="tab-icon">üìÑ</span>
                            <span class="tab-name">README.md</span>
                            <span class="tab-close">√ó</span>
                        </div>
                    </div>
                    <div class="editor">
                        <div class="line-numbers">
                            <div class="line-number">1</div>
                        </div>
                        <div class="scroll-container">
                            <div class="editor-content scroll-content" id="editor-content">
                            </div>
                            <div class="custom-scrollbar" id="editor-scrollbar">
                                <div class="custom-scrollbar-thumb" id="editor-thumb"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Terminal Resize Handle -->
            <div class="resize-handle terminal-resize"></div>

            <!-- Terminal Panel -->
            <div class="terminal-panel">
                <div class="terminal-header">
                    <div class="terminal-tabs">
                        <div class="terminal-tab active">
                            <span class="terminal-icon">‚ö°</span>
                            <span>Terminal</span>
                        </div>
                    </div>
                </div>
                <div class="terminal-content">
                    <div class="scroll-container">
                        <div class="terminal-output scroll-content" id="terminal-output">
                            <div class="terminal-input-line">
                                <span class="prompt">kian@letta:~/kianjones.com$</span>
                                <span class="input-container">
                                    <input type="text" id="terminal-input" placeholder="" />
                                </span>
                            </div>
                        </div>
                        <div class="custom-scrollbar" id="terminal-scrollbar">
                            <div class="custom-scrollbar-thumb" id="terminal-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Posts configuration
            const POSTS_CONFIG = [
                {
                    id: '2021-language-learning-review',
                    title: '2021 Language Learning Review',
                    folder: '2021 Language Learning Review',
                    filename: '2021-language-learning-review.html',
                    date: '2021-01-10',
                    icon: 'üó£Ô∏è'
                },
                {
                    id: '2022-resolutions-part-1-end-of-year-review', 
                    title: '2022 Resolutions Part 1 End of Year Review',
                    folder: '2022 Resolutions Part 1 End of Year Review',
                    filename: '2021-year-end-review.html',
                    date: '2021-01-03',
                    icon: 'üìÖ'
                }
            ];

            // Function to load post content dynamically
            async function loadPostContent(postConfig) {
                try {
                    const postUrl = `posts/${encodeURIComponent(postConfig.folder)}/${postConfig.filename}`;
                    console.log('Loading post from:', postUrl);
                    const response = await fetch(postUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const html = await response.text();
                    
                    // Extract content div
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const contentDiv = doc.querySelector('.content');
                    
                    if (contentDiv) {
                        let content = contentDiv.innerHTML;
                        // Fix image paths
                        const postDir = `posts/${encodeURIComponent(postConfig.folder)}/`;
                        content = content.replace(/src="(?!http|\/)/g, `src="${postDir}`);
                        return content;
                    }
                    
                    return `<h1>${postConfig.title}</h1><p>Content could not be loaded. <a href="${postUrl}" target="_blank">View original post ‚Üí</a></p>`;
                    
                } catch (error) {
                    console.error('Failed to load post:', error);
                    return `<h1>${postConfig.title}</h1><p>Error loading post content. <a href="posts/${encodeURIComponent(postConfig.folder)}/${postConfig.filename}" target="_blank">View original post ‚Üí</a></p>`;
                }
            }

            // Function to load static content from readme.md.html
            async function loadStaticContent() {
                try {
                    console.log('Loading static content from readme.md.html');
                    const response = await fetch('readme.md.html');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const html = await response.text();
                    
                    // Extract content div
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const contentDiv = doc.querySelector('.content');
                    
                    if (contentDiv) {
                        return contentDiv.innerHTML;
                    }
                    
                    return '<h1>Error</h1><p>Content could not be loaded from readme.md.html</p>';
                    
                } catch (error) {
                    console.error('Failed to load static content:', error);
                    return '<h1>Error</h1><p>Error loading static content.</p>';
                }
            }

            // Cache for loaded static content
            let cachedStaticContent = null;

            // Load file function
            async function loadFile(fileName, updateUrl = true) {
                const editorContent = document.getElementById('editor-content');
                
                // Update URL hash if requested
                if (updateUrl) {
                    window.location.hash = fileName;
                }
                
                // Check if it's a dynamic post
                const postConfig = POSTS_CONFIG.find(post => post.id === fileName);
                let content = '';
                let displayName = fileName;
                let icon = 'üìÑ';
                
                if (postConfig) {
                    // It's a dynamic post
                    displayName = postConfig.title;
                    icon = postConfig.icon;
                    
                    try {
                        content = await loadPostContent(postConfig);
                    } catch (error) {
                        console.error('Failed to load post:', error);
                        content = `<h1>${postConfig.title}</h1><p>Error loading post content.</p>`;
                    }
                } else {
                    // Static content - load from readme.md.html
                    if (!cachedStaticContent) {
                        try {
                            cachedStaticContent = await loadStaticContent();
                        } catch (error) {
                            console.error('Failed to load static content:', error);
                            cachedStaticContent = '<h1>Error</h1><p>Error loading static content.</p>';
                        }
                    }
                    
                    content = cachedStaticContent || 'File not found';
                    
                    // Set display names and icons for static files
                    const staticNames = {
                        'readme': 'README.md',
                        'bio': 'bio.md',
                        'contact': 'contact.md',
                        'letta-infra': 'letta-infrastructure.md'
                    };
                    
                    const staticIcons = {
                        'readme': 'üìÑ',
                        'bio': 'üë§',
                        'contact': 'üìß',
                        'letta-infra': 'üèóÔ∏è'
                    };
                    
                    displayName = staticNames[fileName] || fileName;
                    icon = staticIcons[fileName] || 'üìÑ';
                }
                
                // Update tab
                const tabName = document.querySelector('.tab-name');
                const tabIcon = document.querySelector('.tab-icon');
                
                tabIcon.textContent = icon;
                tabName.textContent = displayName;
                
                // Update title bar
                document.querySelector('.title-bar-center').textContent = displayName;
                
                // Update content
                editorContent.innerHTML = content;
                
                // Update line numbers after content change
                updateLineNumbers();
            }

            // Initialize posts sidebar
            function initializePosts() {
                console.log('Initializing posts sidebar...');
                
                const postsContainer = document.getElementById('posts-folder-content');
                if (!postsContainer) {
                    console.error('Posts container not found!');
                    return;
                }
                
                // Clear existing content
                postsContainer.innerHTML = '';
                
                // Add posts from config
                POSTS_CONFIG.forEach(post => {
                    console.log('Adding post:', post.title);
                    
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file';
                    fileDiv.onclick = (e) => {
                        console.log('Clicking post:', post.id);
                        
                        // Update active states before loading
                        document.querySelectorAll('.file').forEach(f => f.classList.remove('active'));
                        fileDiv.classList.add('active');
                        
                        loadFile(post.id);
                    };
                    
                    fileDiv.innerHTML = `
                        <span class="file-icon">${post.icon}</span>
                        <span class="file-name">${post.title}</span>
                    `;
                    
                    postsContainer.appendChild(fileDiv);
                });
                
                console.log('Posts sidebar initialized with', POSTS_CONFIG.length, 'posts');
            }

            // Toggle folder function
            function toggleFolder(header) {
                const folder = header.closest('.folder');
                const content = folder.querySelector('.folder-content');
                const icon = header.querySelector('.folder-icon');
                
                if(folder.classList.contains('open')) {
                    folder.classList.remove('open');
                    content.style.display = 'none';
                    icon.textContent = 'üìÅ';
                } else {
                    folder.classList.add('open');
                    content.style.display = 'block'; 
                    icon.textContent = 'üìÇ';
                }
            }

            // Function to update line numbers for current content
            function updateLineNumbers() {
                const editorContent = document.getElementById('editor-content');
                const content = editorContent.innerHTML;
                
                // Count actual rendered lines by creating a temporary element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                tempDiv.style.cssText = 'position: absolute; left: -9999px; top: -9999px; width: auto; height: auto; white-space: pre-wrap; font-family: Monaco, monospace; font-size: 14px; line-height: 1.5;';
                document.body.appendChild(tempDiv);
                
                // Get the actual height and calculate lines
                const lineHeight = parseInt(window.getComputedStyle(tempDiv).lineHeight);
                const totalHeight = tempDiv.offsetHeight;
                const lines = Math.max(1, Math.ceil(totalHeight / lineHeight));
                
                document.body.removeChild(tempDiv);
                
                // Update line numbers
                const lineNumbers = document.querySelector('.line-numbers');
                lineNumbers.innerHTML = '';
                for(let i = 1; i <= lines; i++) {
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'line-number';
                    lineDiv.textContent = i;
                    lineNumbers.appendChild(lineDiv);
                }
                
                // Setup scroll synchronization
                setupScrollSync();
            }
            
            // Function to synchronize line numbers scroll with content scroll
            function setupScrollSync() {
                const editorContent = document.getElementById('editor-content');
                const lineNumbers = document.querySelector('.line-numbers');
                
                // Remove existing scroll listener if any
                editorContent.removeEventListener('scroll', syncLineNumbersScroll);
                
                // Add scroll synchronization
                editorContent.addEventListener('scroll', syncLineNumbersScroll);
            }
            
            function syncLineNumbersScroll() {
                const editorContent = document.getElementById('editor-content');
                const lineNumbers = document.querySelector('.line-numbers');
                
                // Instead of transform, sync the scroll position directly
                lineNumbers.scrollTop = editorContent.scrollTop;
            }

            // Terminal functionality
            const terminalInput = document.getElementById('terminal-input');
            const terminalOutput = document.getElementById('terminal-output');
            
            // Generate file system structure dynamically
            function generateFileSystem() {
                const postsChildren = {};
                POSTS_CONFIG.forEach(post => {
                    postsChildren[post.title] = { type: 'file', content: post.id };
                });
                
                return {
                    '/': {
                        'README.md': { type: 'file', content: 'readme' },
                        'posts/': {
                            type: 'directory',
                            children: postsChildren
                        }
                    }
                };
            }
            
            let fileSystem = generateFileSystem();
            let currentPath = '/';

            const commands = {
                help: () => `Available commands:
  ls [-al] [dir] - list files in directory
                   -a  show all files (including . and ..)
                   -l  long format with details
  cat <file>     - show file content  
  clear          - clear terminal
  whoami         - show user info
  pwd            - current directory
  cd <dir>       - change directory`,
                
                ls: (...args) => {
                    let flags = [];
                    let target = '.';
                    
                    // Parse arguments to separate flags from directory
                    for (const arg of args) {
                        if (arg && arg.startsWith('-')) {
                            flags.push(...arg.slice(1).split(''));
                        } else if (arg) {
                            target = arg;
                        }
                    }
                    
                    const targetPath = resolvePath(currentPath, target);
                    const dirObj = getDirectoryContents(targetPath);
                    
                    if (!dirObj) {
                        return `ls: ${target}: No such file or directory`;
                    }
                    
                    if (dirObj.type === 'file') {
                        return formatLsOutput([target.split('/').pop()], flags);
                    }
                    
                    // Get entries from the correct location
                    let entries;
                    if (dirObj.children) {
                        entries = Object.keys(dirObj.children);
                    } else {
                        entries = Object.keys(dirObj).filter(key => key !== 'type');
                    }
                    
                    // Add hidden entries if -a flag is present
                    if (flags.includes('a')) {
                        entries = ['.', '..', ...entries];
                    }
                    
                    entries.sort();
                    return formatLsOutput(entries, flags, dirObj);
                },

                cd: (dir = '/') => {
                    const newPath = resolvePath(currentPath, dir);
                    const dirObj = getDirectoryContents(newPath);
                    
                    if (!dirObj) {
                        return `cd: ${dir}: No such file or directory`;
                    }
                    
                    if (dirObj.type === 'file') {
                        return `cd: ${dir}: Not a directory`;
                    }
                    
                    currentPath = newPath;
                    return '';
                },
                
                pwd: () => `/home/kian/kianjones.com${currentPath === '/' ? '' : currentPath}`,
                
                whoami: () => `kian - Infrastructure Engineer @ Letta`,
                
                clear: () => {
                    terminalOutput.innerHTML = '';
                    return '';
                },
                
                cat: async (file) => {
                    if (!file) {
                        return 'cat: missing file operand';
                    }
                    
                    const filePath = resolvePath(currentPath, file);
                    const fileObj = getDirectoryContents(filePath);
                    
                    if (!fileObj) {
                        return `cat: ${file}: No such file or directory`;
                    }
                    
                    if (fileObj.type === 'directory') {
                        return `cat: ${file}: Is a directory`;
                    }
                    
                    // Load static content if not cached
                    if (!cachedStaticContent) {
                        try {
                            cachedStaticContent = await loadStaticContent();
                        } catch (error) {
                            return `cat: ${file}: Error loading content`;
                        }
                    }
                    
                    return cachedStaticContent || `cat: ${file}: No such file or directory`;
                }
            };

            // Format ls output based on flags
            function formatLsOutput(entries, flags, dirObj = null) {
                if (flags.includes('l')) {
                    // Long format
                    const lines = entries.map(entry => {
                        if (entry === '.' || entry === '..') {
                            return `drwxr-xr-x  1 kian  staff    0 Dec 20 10:30 ${entry}`;
                        }
                        
                        const entryObj = dirObj && dirObj.children ? dirObj.children[entry] : null;
                        const isDir = entryObj && entryObj.type === 'directory';
                        const permissions = isDir ? 'drwxr-xr-x' : '-rw-r--r--';
                        const size = isDir ? '0' : '1024';
                        
                        return `${permissions}  1 kian  staff  ${size.padStart(4)} Dec 20 10:30 ${entry}`;
                    });
                    return lines.join('\n');
                } else {
                    // Simple format
                    return entries.join('  ') || '';
                }
            }

            // Helper functions for file system navigation
            function resolvePath(current, target) {
                if (target === '.') return current;
                if (target === '..') {
                    const parts = current.split('/').filter(p => p);
                    if (parts.length === 0) return '/';
                    parts.pop();
                    return parts.length === 0 ? '/' : '/' + parts.join('/');
                }
                if (target.startsWith('/')) return target;
                
                const currentParts = current === '/' ? [] : current.split('/').filter(p => p);
                const targetParts = target.split('/').filter(p => p);
                
                // Process .. and . in the target path
                const resolvedParts = [...currentParts];
                for (const part of targetParts) {
                    if (part === '.') {
                        continue; // Stay in current directory
                    } else if (part === '..') {
                        if (resolvedParts.length > 0) {
                            resolvedParts.pop(); // Go up one level
                        }
                    } else {
                        resolvedParts.push(part);
                    }
                }
                
                return resolvedParts.length === 0 ? '/' : '/' + resolvedParts.join('/');
            }

            function getDirectoryContents(path) {
                if (path === '/') return fileSystem['/'];
                
                const parts = path.split('/').filter(p => p);
                let current = fileSystem['/'];
                
                for (const part of parts) {
                    // Try both with and without trailing slash
                    const dirKey = part + '/';
                    const fileKey = part;
                    
                    // Check in children first (for directories)
                    if (current.children) {
                        if (current.children[dirKey]) {
                            current = current.children[dirKey];
                            continue;
                        }
                        if (current.children[fileKey]) {
                            current = current.children[fileKey];
                            continue;
                        }
                    }
                    
                    // Check in current level
                    if (current[dirKey]) {
                        current = current[dirKey];
                        continue;
                    }
                    if (current[fileKey]) {
                        current = current[fileKey];
                        continue;
                    }
                    
                    // Not found
                    return null;
                }
                
                return current;
            }

            // Command history
            let commandHistory = [];
            let historyIndex = -1;

            async function executeCommand(commandLine, showOnly = false) {
                // Add command to output (always show the prompt line, even for empty commands)
                const cmdDiv = document.createElement('div');
                cmdDiv.className = 'terminal-line';
                const currentDir = currentPath === '/' ? '' : currentPath;
                cmdDiv.innerHTML = `<span class="prompt">kian@letta:~/kianjones.com${currentDir}$</span> ${commandLine}`;
                
                // Insert before the input line
                const inputLine = document.querySelector('.terminal-input-line');
                terminalOutput.insertBefore(cmdDiv, inputLine);
                
                // If showOnly is true (for tab completion), don't execute
                if (showOnly) return;
                
                // If empty command, just add new prompt
                if (!commandLine.trim()) {
                    return;
                }

                // Parse and execute
                const parts = commandLine.split(' ');
                const cmd = parts[0];
                const args = parts.slice(1);

                let result = '';
                if (commands[cmd]) {
                    result = await commands[cmd](...args);
                } else {
                    result = `bash: ${cmd}: command not found`;
                }

                if (result) {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'output';
                    resultDiv.textContent = result;
                    
                    // Insert before the input line
                    const inputLine = document.querySelector('.terminal-input-line');
                    terminalOutput.insertBefore(resultDiv, inputLine);
                }

                // Update the input prompt only if directory changed
                if (cmd === 'cd' && !result) {
                    updatePrompt();
                }

                // Scroll to bottom and maintain input focus
                setTimeout(() => {
                    terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    terminalInput.focus();
                }, 0);
            }

            function updatePrompt() {
                const promptElement = document.querySelector('.terminal-input-line .prompt');
                const currentDir = currentPath === '/' ? '' : currentPath;
                promptElement.textContent = `kian@letta:~/kianjones.com${currentDir}$`;
            }

            terminalInput.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const command = terminalInput.value.trim();
                    await executeCommand(command);
                    if (command) {
                        commandHistory.push(command);
                    }
                    historyIndex = commandHistory.length;
                    terminalInput.value = '';
                    // Ensure cursor stays at the beginning
                    setTimeout(() => {
                        terminalInput.focus();
                    }, 0);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        terminalInput.value = commandHistory[historyIndex];
                        // Move cursor to end
                        setTimeout(() => {
                            terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
                        }, 0);
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        terminalInput.value = commandHistory[historyIndex];
                    } else {
                        historyIndex = commandHistory.length;
                        terminalInput.value = '';
                    }
                    // Move cursor to end
                    setTimeout(() => {
                        terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
                    }, 0);
                }
            });

            // Terminal click to focus
            document.querySelector('.terminal-content').addEventListener('click', (e) => {
                terminalInput.focus();
            });

            // Panel Resizing
            let isResizing = false;
            let currentResizer = null;

            // Sidebar resize
            document.querySelector('.sidebar-resize').addEventListener('mousedown', (e) => {
                isResizing = true;
                currentResizer = 'sidebar';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });

            // Terminal resize
            document.querySelector('.terminal-resize').addEventListener('mousedown', (e) => {
                isResizing = true;
                currentResizer = 'terminal';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });

            function handleResize(e) {
                if (!isResizing) return;

                if (currentResizer === 'sidebar') {
                    const sidebar = document.querySelector('.sidebar');
                    const newWidth = e.clientX;
                    if (newWidth >= 200 && newWidth <= 500) {
                        sidebar.style.width = newWidth + 'px';
                    }
                } else if (currentResizer === 'terminal') {
                    const terminal = document.querySelector('.terminal-panel');
                    const newHeight = window.innerHeight - e.clientY;
                    if (newHeight >= 150 && newHeight <= 400) {
                        terminal.style.height = newHeight + 'px';
                    }
                }
            }

            function stopResize() {
                isResizing = false;
                currentResizer = null;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }

            // Theme Switcher
            const themes = [
                { name: 'Purple', class: '', icon: 'üü£' },
                { name: 'Orange', class: 'theme-orange', icon: 'üü†' },
                { name: 'Green', class: 'theme-green', icon: 'üü¢' },
                { name: 'Red', class: 'theme-red', icon: 'üî¥' },
                { name: 'Cyan', class: 'theme-cyan', icon: 'üîµ' },
                { name: 'Yellow', class: 'theme-yellow', icon: 'üü°' }
            ];
            
            let currentTheme = 0;
            
            // Theme switcher dropdown functionality
            document.getElementById('theme-switcher').addEventListener('click', (e) => {
                e.stopPropagation();
                const dropdown = document.getElementById('theme-dropdown');
                dropdown.classList.toggle('show');
                updateActiveTheme();
            });
            
            // Handle theme selection
            document.querySelectorAll('.theme-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const themeIndex = parseInt(e.target.dataset.theme);
                    applyTheme(themeIndex);
                    document.getElementById('theme-dropdown').classList.remove('show');
                });
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', () => {
                document.getElementById('theme-dropdown').classList.remove('show');
            });
            
            function applyTheme(themeIndex) {
                // Remove current theme
                document.body.className = '';
                
                currentTheme = themeIndex;
                const theme = themes[currentTheme];
                
                // Apply new theme
                if (theme.class) {
                    document.body.className = theme.class;
                }
                
                // Store theme preference
                localStorage.setItem('theme', currentTheme.toString());
                updateActiveTheme();
            }
            
            function updateActiveTheme() {
                document.querySelectorAll('.theme-option').forEach((option, index) => {
                    option.classList.toggle('active', index === currentTheme);
                });
            }
            
            // Load saved theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(parseInt(savedTheme));
            }

            // Handle URL hash changes
            function handleHashChange() {
                const hash = window.location.hash.slice(1); // Remove the #
                if (hash) {
                    // Check if this is a valid post ID or static file
                    const postConfig = POSTS_CONFIG.find(post => post.id === hash);
                    const isValidFile = postConfig || hash === 'readme';
                    
                    if (isValidFile) {
                        // Ensure posts folder is open if loading a post
                        if (postConfig) {
                            const postsFolders = document.querySelectorAll('.folder');
                            postsFolders.forEach(folder => {
                                const folderName = folder.querySelector('.folder-name');
                                if (folderName && folderName.textContent === 'posts/') {
                                    if (!folder.classList.contains('open')) {
                                        const folderHeader = folder.querySelector('.folder-header');
                                        if (folderHeader) {
                                            toggleFolder(folderHeader);
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Find and activate the correct file in sidebar
                        const fileElements = document.querySelectorAll('.file');
                        fileElements.forEach(fileEl => {
                            fileEl.classList.remove('active');
                            const fileName = fileEl.querySelector('.file-name');
                            if (fileName) {
                                if (postConfig && fileName.textContent === postConfig.title) {
                                    fileEl.classList.add('active');
                                } else if (fileName.textContent === 'README.md' && hash === 'readme') {
                                    fileEl.classList.add('active');
                                }
                            }
                        });
                        
                        loadFile(hash, false); // Don't update URL again
                    } else {
                        // Invalid hash, default to readme
                        loadFile('readme', false);
                    }
                } else {
                    // No hash, default to readme
                    loadFile('readme', false);
                }
            }
            
            // Listen for hash changes
            window.addEventListener('hashchange', handleHashChange);

            // Initialize
            document.addEventListener('DOMContentLoaded', async () => {
                // Initialize posts sidebar
                initializePosts();
                
                // Load static content into cache
                try {
                    cachedStaticContent = await loadStaticContent();
                } catch (error) {
                    console.error('Failed to load static content on init:', error);
                }
                
                // Small delay to ensure DOM is fully ready, then handle URL hash
                setTimeout(() => {
                    handleHashChange();
                }, 100);
                
                // Focus terminal input
                terminalInput.focus();
                
                // Show help command on load
                await executeCommand('help');
            });
        </script>
        
    </body>

</html>