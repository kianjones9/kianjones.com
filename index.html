<!doctype html>

<html lang="en">
    
    <head>
        <meta charset="utf-8">

        <title>kianjones.com - Infrastructure Engineer</title>
        <meta name="description" content="Kian Jones - Infrastructure Engineer @ Letta, building systems for AI agents">
        
        <link rel="stylesheet" href="style.css">
        
    </head>
    
    <body>
        
        <div class="ide-container">
            <!-- Title Bar -->
            <div class="title-bar">
                <div class="title-bar-left">
                    <span class="window-controls">
                        <span class="control close"></span>
                        <span class="control minimize"></span>
                        <span class="control maximize"></span>
                    </span>
                    <span class="app-title">kianjones.com - VS Code</span>
                </div>
                <div class="title-bar-center">README.md</div>
                <div class="title-bar-right">
                    <div class="theme-switcher-container">
                        <button id="theme-switcher" class="theme-button">🎨</button>
                        <div id="theme-dropdown" class="theme-dropdown">
                            <div class="theme-option" data-theme="0">🟣 Purple</div>
                            <div class="theme-option" data-theme="1">🟠 Orange</div>
                            <div class="theme-option" data-theme="2">🟢 Green</div>
                            <div class="theme-option" data-theme="3">🔴 Red</div>
                            <div class="theme-option" data-theme="4">🔵 Cyan</div>
                            <div class="theme-option" data-theme="5">🟡 Yellow</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main IDE Layout -->
            <div class="ide-main">
                <!-- Sidebar -->
                <div class="sidebar">
                    <div class="sidebar-header">
                        <div class="sidebar-title">EXPLORER</div>
                    </div>
                    <div class="file-tree">
                        <div class="folder open">
                            <div class="folder-header" onclick="toggleFolder(this)">
                                <span class="folder-icon">📁</span>
                                <span class="folder-name">kianjones.com</span>
                            </div>
                            <div class="folder-content">
                                <div class="file active" onclick="loadFile('readme')">
                                    <span class="file-icon">📄</span>
                                    <span class="file-name">README.md</span>
                                </div>
                                <div class="file" onclick="loadFile('bio')">
                                    <span class="file-icon">👤</span>
                                    <span class="file-name">bio.md</span>
                                </div>
                                <div class="file" onclick="loadFile('contact')">
                                    <span class="file-icon">📧</span>
                                    <span class="file-name">contact.md</span>
                                </div>
                                <div class="folder">
                                    <div class="folder-header" onclick="toggleFolder(this)">
                                        <span class="folder-icon">📁</span>
                                        <span class="folder-name">posts/</span>
                                    </div>
                                    <div class="folder-content">
                                        <div class="file" onclick="loadFile('scaling-agents')">
                                            <span class="file-icon">🚀</span>
                                            <span class="file-name">scaling-ai-agents.md</span>
                                        </div>
                                        <div class="file" onclick="loadFile('observability')">
                                            <span class="file-icon">📊</span>
                                            <span class="file-name">observability-agents.md</span>
                                        </div>
                                        <div class="file" onclick="loadFile('networking')">
                                            <span class="file-icon">🌐</span>
                                            <span class="file-name">network-architecture.md</span>
                                        </div>
                                        <div class="file" onclick="loadFile('gpu-infra')">
                                            <span class="file-icon">⚡</span>
                                            <span class="file-name">gpu-infrastructure.md</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="folder">
                                    <div class="folder-header" onclick="toggleFolder(this)">
                                        <span class="folder-icon">📁</span>
                                        <span class="folder-name">projects/</span>
                                    </div>
                                    <div class="folder-content">
                                        <div class="file" onclick="loadFile('letta-infra')">
                                            <span class="file-icon">🏗️</span>
                                            <span class="file-name">letta-infrastructure.md</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar Resize Handle -->
                <div class="resize-handle sidebar-resize"></div>

                <!-- Content Area -->
                <div class="content-area">
                    <div class="tab-bar">
                        <div class="tab active">
                            <span class="tab-icon">📄</span>
                            <span class="tab-name">README.md</span>
                            <span class="tab-close">×</span>
                        </div>
                    </div>
                    <div class="editor">
                        <div class="line-numbers">
                            <div class="line-number">1</div>
                            <div class="line-number">2</div>
                            <div class="line-number">3</div>
                            <div class="line-number">4</div>
                            <div class="line-number">5</div>
                            <div class="line-number">6</div>
                            <div class="line-number">7</div>
                            <div class="line-number">8</div>
                            <div class="line-number">9</div>
                            <div class="line-number">10</div>
                            <div class="line-number">11</div>
                            <div class="line-number">12</div>
                            <div class="line-number">13</div>
                            <div class="line-number">14</div>
                            <div class="line-number">15</div>
                            <div class="line-number">16</div>
                            <div class="line-number">17</div>
                            <div class="line-number">18</div>
                            <div class="line-number">19</div>
                            <div class="line-number">20</div>
                        </div>
                        <div class="scroll-container">
                            <div class="editor-content scroll-content" id="editor-content">
                                <h1>Kian Jones</h1>

                                <p><strong>Infrastructure Engineer @ <a href="https://letta.com">Letta</a></strong><br>
                                Building the backbone for next-generation AI agents</p>

                                <h2>About</h2>

                                <p>Infrastructure specialist with deep expertise in cloud architecture, networking, 
                                and observability. Currently architecting scalable systems that enable AI agents 
                                to operate reliably at massive scale.</p>

                                <h2>Experience</h2>

                                <ul>
                                <li><strong>Letta</strong> - Infrastructure Engineer (AI Agent Platform)</li>
                                <li><strong>Covariant</strong> - Cloud & Infrastructure</li>
                                <li><strong>Meta</strong> - Platform Engineering</li>
                                <li><strong>Nokia</strong> - Network Infrastructure</li>
                                <li><strong>CENGN</strong> - Research & Development</li>
                                <li><strong>Environment Canada</strong> - Systems Engineering</li>
                                <li><strong>SurveyMonkey</strong> - Backend Infrastructure</li>
                                </ul>

                                <h2>Expertise</h2>

                                <h3>🏗️ Cloud Architecture</h3>
                                <p>AWS, GCP, Kubernetes, Terraform, Infrastructure as Code</p>

                                <h3>📊 Observability</h3>
                                <p>Monitoring, Logging, Distributed Tracing, Performance Metrics</p>

                                <h3>🌐 Networking</h3>
                                <p>Load Balancing, CDN, Service Mesh, Network Security</p>

                                <h3>🤖 AI Infrastructure</h3>
                                <p>GPU Clusters, Model Serving, Agent Orchestration, Auto-scaling</p>

                                <h2>Current Focus</h2>

                                <p>Building the infrastructure that powers thousands of concurrent AI agents at Letta.
                                From Kubernetes orchestration to observability systems, creating the foundation
                                for the future of AI agent interactions.</p>

                                <hr>
                                <p><em>Navigate using the file explorer → or try the terminal below ↓</em></p>
                            </div>
                            <div class="custom-scrollbar" id="editor-scrollbar">
                                <div class="custom-scrollbar-thumb" id="editor-thumb"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Terminal Resize Handle -->
            <div class="resize-handle terminal-resize"></div>

            <!-- Terminal Panel -->
            <div class="terminal-panel">
                <div class="terminal-header">
                    <div class="terminal-tabs">
                        <div class="terminal-tab active">
                            <span class="terminal-icon">⚡</span>
                            <span>Terminal</span>
                        </div>
                    </div>
                </div>
                <div class="terminal-content">
                    <div class="scroll-container">
                        <div class="terminal-output scroll-content" id="terminal-output">
                            <div class="terminal-input-line">
                                <span class="prompt">kian@letta:~/kianjones.com$</span>
                                <span class="input-container">
                                    <input type="text" id="terminal-input" placeholder="" />
                                </span>
                            </div>
                        </div>
                        <div class="custom-scrollbar" id="terminal-scrollbar">
                            <div class="custom-scrollbar-thumb" id="terminal-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // File content storage
            const fileContent = {
                'readme': `<h1>Kian Jones</h1>

<p><strong>Infrastructure Engineer @ <a href="https://letta.com">Letta</a></strong><br>
Building the backbone for next-generation AI agents</p>

<h2>About</h2>

<p>Infrastructure specialist with deep expertise in cloud architecture, networking, 
and observability. Currently architecting scalable systems that enable AI agents 
to operate reliably at massive scale.</p>

<h2>Experience</h2>

<ul>
<li><strong>Letta</strong> - Infrastructure Engineer (AI Agent Platform)</li>
<li><strong>Covariant</strong> - Cloud & Infrastructure</li>
<li><strong>Meta</strong> - Platform Engineering</li>
<li><strong>Nokia</strong> - Network Infrastructure</li>
<li><strong>CENGN</strong> - Research & Development</li>
<li><strong>Environment Canada</strong> - Systems Engineering</li>
<li><strong>SurveyMonkey</strong> - Backend Infrastructure</li>
</ul>

<h2>Expertise</h2>

<h3>🏗️ Cloud Architecture</h3>
<p>AWS, GCP, Kubernetes, Terraform, Infrastructure as Code</p>

<h3>📊 Observability</h3>
<p>Monitoring, Logging, Distributed Tracing, Performance Metrics</p>

<h3>🌐 Networking</h3>
<p>Load Balancing, CDN, Service Mesh, Network Security</p>

<h3>🤖 AI Infrastructure</h3>
<p>GPU Clusters, Model Serving, Agent Orchestration, Auto-scaling</p>

<h2>Current Focus</h2>

<p>Building the infrastructure that powers thousands of concurrent AI agents at Letta.
From Kubernetes orchestration to observability systems, creating the foundation
for the future of AI agent interactions.</p>

<hr>
<p><em>Navigate using the file explorer → or try the terminal below ↓</em></p>`,
                
                'bio': `<h1>Bio</h1>

<h2>Kian Jones - Infrastructure Engineer</h2>

<p>Currently building the foundational systems that power AI agents at Letta. 
Passionate about creating robust, scalable infrastructure that enables the 
next generation of artificial intelligence to operate seamlessly.</p>

<h3>Background</h3>

<p>With extensive experience across cloud platforms, networking, and observability,
I specialize in designing systems that can handle massive scale while maintaining
reliability and performance.</p>

<h3>Philosophy</h3>

<p>Great infrastructure is invisible - it just works. My focus is on building
systems that developers and AI agents can rely on, allowing them to focus
on innovation rather than operational concerns.</p>`,

                'contact': `<h1>Contact</h1>

<h2>Get in Touch</h2>

<p><strong>Email</strong>: <a href="mailto:kian@kianjones.com">kian@kianjones.com</a><br>
<strong>LinkedIn</strong>: <a href="https://linkedin.com/in/kianjones">linkedin.com/in/kianjones</a><br>
<strong>GitHub</strong>: <a href="https://github.com/kianjones">github.com/kianjones</a><br>
<strong>Twitter</strong>: <a href="https://twitter.com/kianjones">@kianjones</a></p>

<h3>Open to Discuss</h3>

<ul>
<li>Infrastructure architecture and scaling challenges</li>
<li>AI/ML platform engineering opportunities</li>
<li>Cloud-native system design</li>
<li>Observability and monitoring strategies</li>
<li>Open source contributions</li>
</ul>

<hr>
<p><em>Always happy to talk about infrastructure, AI agents, and building scalable systems!</em></p>`,

                'scaling-agents': `# Scaling AI Agent Infrastructure

*Coming Soon - Technical Deep Dive*

## Overview

How we built cloud infrastructure to handle thousands of concurrent AI agents 
at Letta. From Kubernetes orchestration to auto-scaling strategies.

## Topics Covered

- Container orchestration for agent workloads
- Auto-scaling strategies for unpredictable traffic
- Resource management and cost optimization
- Performance monitoring and alerting

*This post is currently in development. Check back soon!*`,

                'observability': `# Observability for Agent Systems  

*Coming Soon - Monitoring Guide*

## Overview

Building comprehensive monitoring, logging, and tracing for AI agent platforms. 
How to debug distributed agent conversations and track system health.

## Key Areas

- Distributed tracing for agent conversations
- Custom metrics for agent performance
- Log aggregation and analysis
- Real-time alerting systems

*This post is currently in development. Check back soon!*`,

                'networking': `# Network Architecture for AI Agents

*Coming Soon - Architecture Guide*

## Overview

Designing network topologies, load balancing, and service mesh configurations 
for high-throughput AI agent communication.

## Topics

- Service mesh implementation
- Load balancing strategies  
- Network security for agent traffic
- Performance optimization

*This post is currently in development. Check back soon!*`,

                'gpu-infra': `# GPU Infrastructure Management

*Coming Soon - Hardware Guide*

## Overview

Managing GPU clusters for AI agent workloads. Resource scheduling, cost 
optimization, and performance tuning for ML inference at scale.

## Coverage

- GPU cluster management
- Resource scheduling algorithms
- Cost optimization strategies
- Performance benchmarking

*This post is currently in development. Check back soon!*`,

                'letta-infra': `# Letta Infrastructure Project

## Overview

Building the scalable infrastructure backbone for Letta's AI agent platform.

### Responsibilities

- Kubernetes cluster management and optimization
- CI/CD pipeline design and implementation  
- Monitoring and observability systems
- Cost optimization and resource management

### Technologies

- **Cloud**: AWS, GCP
- **Orchestration**: Kubernetes, Docker
- **Monitoring**: Prometheus, Grafana, Jaeger
- **IaC**: Terraform, Helm

### Impact

Enabling thousands of concurrent AI agent conversations while maintaining 
sub-second response times and 99.9% uptime.`
            };

            // Load file function
            function loadFile(fileName) {
                const content = fileContent[fileName] || 'File not found';
                const editorContent = document.getElementById('editor-content');
                
                // Remove active class from all files
                document.querySelectorAll('.file').forEach(f => f.classList.remove('active'));
                
                // Add active class to clicked file
                event.target.closest('.file').classList.add('active');
                
                // Update tab
                const tabName = document.querySelector('.tab-name');
                const tabIcon = document.querySelector('.tab-icon');
                const icons = {
                    'readme': '📄',
                    'bio': '👤', 
                    'contact': '📧',
                    'scaling-agents': '🚀',
                    'observability': '📊',
                    'networking': '🌐',
                    'gpu-infra': '⚡',
                    'letta-infra': '🏗️'
                };
                const names = {
                    'readme': 'README.md',
                    'bio': 'bio.md',
                    'contact': 'contact.md', 
                    'scaling-agents': 'scaling-ai-agents.md',
                    'observability': 'observability-agents.md',
                    'networking': 'network-architecture.md',
                    'gpu-infra': 'gpu-infrastructure.md',
                    'letta-infra': 'letta-infrastructure.md'
                };
                
                tabIcon.textContent = icons[fileName] || '📄';
                tabName.textContent = names[fileName] || fileName;
                
                // Update title bar
                document.querySelector('.title-bar-center').textContent = names[fileName] || fileName;
                
                // Update content
                editorContent.innerHTML = content;
                
                // Update line numbers after content change
                updateLineNumbers();
            }

            // Toggle folder function
            function toggleFolder(header) {
                const folder = header.closest('.folder');
                const content = folder.querySelector('.folder-content');
                const icon = header.querySelector('.folder-icon');
                
                if(folder.classList.contains('open')) {
                    folder.classList.remove('open');
                    content.style.display = 'none';
                    icon.textContent = '📁';
                } else {
                    folder.classList.add('open');
                    content.style.display = 'block'; 
                    icon.textContent = '📂';
                }
            }

            // Terminal functionality
            const terminalInput = document.getElementById('terminal-input');
            const terminalOutput = document.getElementById('terminal-output');
            
            const commands = {
                help: () => `Available commands:
  ls          - list files
  cat <file>  - show file content  
  clear       - clear terminal
  whoami      - show user info
  pwd         - current directory`,
                
                ls: () => `README.md  bio.md  contact.md  posts/  projects/`,
                
                pwd: () => `/home/kian/kianjones.com`,
                
                whoami: () => `kian - Infrastructure Engineer @ Letta`,
                
                clear: () => {
                    terminalOutput.innerHTML = '';
                    return '';
                },
                
                cat: (file) => {
                    const fileMap = {
                        'README.md': 'readme',
                        'bio.md': 'bio', 
                        'contact.md': 'contact'
                    };
                    const content = fileContent[fileMap[file]];
                    return content || `cat: ${file}: No such file or directory`;
                }
            };

            // Command history
            let commandHistory = [];
            let historyIndex = -1;

            terminalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const command = terminalInput.value.trim();
                    executeCommand(command);
                    if (command) {
                        commandHistory.push(command);
                    }
                    historyIndex = commandHistory.length;
                    terminalInput.value = '';
                    // Ensure cursor stays at the beginning
                    setTimeout(() => {
                        terminalInput.focus();
                    }, 0);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        terminalInput.value = commandHistory[historyIndex];
                        // Move cursor to end
                        setTimeout(() => {
                            terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
                        }, 0);
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        terminalInput.value = commandHistory[historyIndex];
                    } else {
                        historyIndex = commandHistory.length;
                        terminalInput.value = '';
                    }
                    // Move cursor to end
                    setTimeout(() => {
                        terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
                    }, 0);
                }
            });

            function executeCommand(commandLine) {
                // Add command to output (always show the prompt line, even for empty commands)
                const cmdDiv = document.createElement('div');
                cmdDiv.className = 'terminal-line';
                cmdDiv.innerHTML = `<span class="prompt">kian@letta:~/kianjones.com$</span> ${commandLine}`;
                
                // Insert before the input line
                const inputLine = document.querySelector('.terminal-input-line');
                terminalOutput.insertBefore(cmdDiv, inputLine);
                
                // If empty command, just add new prompt
                if (!commandLine.trim()) {
                    return;
                }

                // Parse and execute
                const parts = commandLine.split(' ');
                const cmd = parts[0];
                const args = parts.slice(1);

                let result = '';
                if (commands[cmd]) {
                    result = commands[cmd](...args);
                } else {
                    result = `bash: ${cmd}: command not found`;
                }

                if (result) {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'output';
                    resultDiv.textContent = result;
                    
                    // Insert before the input line
                    const inputLine = document.querySelector('.terminal-input-line');
                    terminalOutput.insertBefore(resultDiv, inputLine);
                }

                // Scroll to bottom and maintain input focus
                setTimeout(() => {
                    terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    terminalInput.focus();
                }, 0);
            }

            // Cursor blinking
            let cursor = true;
            setInterval(() => {
                const cursorEl = document.getElementById('cursor');
                if(cursor) {
                    cursorEl.style.opacity = 0;
                    cursor = false;
                } else {
                    cursorEl.style.opacity = 1;
                    cursor = true;
                }
            }, 530);

            // Terminal click to focus
            document.querySelector('.terminal-content').addEventListener('click', (e) => {
                terminalInput.focus();
            });


            // Panel Resizing
            let isResizing = false;
            let currentResizer = null;

            // Sidebar resize
            document.querySelector('.sidebar-resize').addEventListener('mousedown', (e) => {
                isResizing = true;
                currentResizer = 'sidebar';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });

            // Terminal resize
            document.querySelector('.terminal-resize').addEventListener('mousedown', (e) => {
                isResizing = true;
                currentResizer = 'terminal';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });

            function handleResize(e) {
                if (!isResizing) return;

                if (currentResizer === 'sidebar') {
                    const sidebar = document.querySelector('.sidebar');
                    const newWidth = e.clientX;
                    if (newWidth >= 200 && newWidth <= 500) {
                        sidebar.style.width = newWidth + 'px';
                    }
                } else if (currentResizer === 'terminal') {
                    const terminal = document.querySelector('.terminal-panel');
                    const newHeight = window.innerHeight - e.clientY;
                    if (newHeight >= 150 && newHeight <= 400) {
                        terminal.style.height = newHeight + 'px';
                    }
                }
            }

            function stopResize() {
                isResizing = false;
                currentResizer = null;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }

            // Theme Switcher
            const themes = [
                { name: 'Purple', class: '', icon: '🟣' },
                { name: 'Orange', class: 'theme-orange', icon: '🟠' },
                { name: 'Green', class: 'theme-green', icon: '🟢' },
                { name: 'Red', class: 'theme-red', icon: '🔴' },
                { name: 'Cyan', class: 'theme-cyan', icon: '🔵' },
                { name: 'Yellow', class: 'theme-yellow', icon: '🟡' }
            ];
            
            let currentTheme = 0;
            
            // Theme switcher dropdown functionality
            document.getElementById('theme-switcher').addEventListener('click', (e) => {
                e.stopPropagation();
                const dropdown = document.getElementById('theme-dropdown');
                dropdown.classList.toggle('show');
                updateActiveTheme();
            });
            
            // Handle theme selection
            document.querySelectorAll('.theme-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const themeIndex = parseInt(e.target.dataset.theme);
                    applyTheme(themeIndex);
                    document.getElementById('theme-dropdown').classList.remove('show');
                });
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', () => {
                document.getElementById('theme-dropdown').classList.remove('show');
            });
            
            function applyTheme(themeIndex) {
                // Remove current theme
                document.body.className = '';
                
                currentTheme = themeIndex;
                const theme = themes[currentTheme];
                
                // Apply new theme
                if (theme.class) {
                    document.body.className = theme.class;
                }
                
                // Store theme preference
                localStorage.setItem('theme', currentTheme.toString());
                updateActiveTheme();
            }
            
            function updateActiveTheme() {
                document.querySelectorAll('.theme-option').forEach((option, index) => {
                    option.classList.toggle('active', index === currentTheme);
                });
            }
            
            // Load saved theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(parseInt(savedTheme));
            }

            // Custom Scrollbar System
            class CustomScrollbar {
                constructor(container, content, scrollbar, thumb) {
                    this.container = container;
                    this.content = content;
                    this.scrollbar = scrollbar;
                    this.thumb = thumb;
                    this.isDragging = false;
                    this.startY = 0;
                    this.startScrollTop = 0;
                    
                    this.init();
                }
                
                init() {
                    // Mouse wheel scrolling
                    this.container.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        const delta = e.deltaY;
                        this.scroll(delta);
                    });
                    
                    // Thumb dragging
                    this.thumb.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        console.log('Thumb mousedown event fired');
                        this.isDragging = true;
                        this.startY = e.clientY;
                        this.startScrollTop = this.content.scrollTop;
                        this.thumb.classList.add('dragging');
                        document.body.style.userSelect = 'none';
                        
                        const handleMouseMove = (e) => {
                            if (!this.isDragging) return;
                            e.preventDefault();
                            console.log('Mouse move during drag');
                            
                            const deltaY = e.clientY - this.startY;
                            const scrollbarHeight = this.scrollbar.clientHeight;
                            const thumbHeight = this.thumb.offsetHeight;
                            const maxScrollTop = this.content.scrollHeight - this.content.clientHeight;
                            
                            if (maxScrollTop <= 0) return;
                            
                            const trackHeight = scrollbarHeight - thumbHeight;
                            const scrollRatio = deltaY / trackHeight;
                            const newScrollTop = this.startScrollTop + (scrollRatio * maxScrollTop);
                            
                            console.log('Drag values:', { deltaY, scrollRatio, newScrollTop, maxScrollTop });
                            
                            this.content.scrollTop = Math.max(0, Math.min(maxScrollTop, newScrollTop));
                            this.updateThumbPosition();
                            this.syncLineNumbers();
                        };
                        
                        const handleMouseUp = () => {
                            this.isDragging = false;
                            this.thumb.classList.remove('dragging');
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                            document.body.style.userSelect = '';
                        };
                        
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    });
                    
                    // Track clicking
                    this.scrollbar.addEventListener('click', (e) => {
                        if (e.target === this.scrollbar) {
                            const rect = this.scrollbar.getBoundingClientRect();
                            const clickY = e.clientY - rect.top;
                            const thumbHeight = this.thumb.offsetHeight;
                            const trackHeight = this.scrollbar.offsetHeight;
                            
                            const scrollRatio = (clickY - thumbHeight / 2) / (trackHeight - thumbHeight);
                            const maxScroll = this.content.scrollHeight - this.content.clientHeight;
                            
                            this.content.scrollTop = scrollRatio * maxScroll;
                            this.updateThumbPosition();
                            this.syncLineNumbers();
                        }
                    });
                    
                    // Initial update
                    this.updateScrollbar();
                    
                    // Content change observer
                    const observer = new MutationObserver(() => {
                        this.updateScrollbar();
                    });
                    observer.observe(this.content, { childList: true, subtree: true });
                }
                
                scroll(delta) {
                    const maxScroll = this.content.scrollHeight - this.content.clientHeight;
                    let newScrollTop = this.content.scrollTop + delta;
                    
                    if (newScrollTop < 0) newScrollTop = 0;
                    if (newScrollTop > maxScroll) newScrollTop = maxScroll;
                    
                    this.content.scrollTop = newScrollTop;
                    this.updateThumbPosition();
                    this.syncLineNumbers();
                }
                
                
                syncLineNumbers() {
                    // Only sync for editor content, not terminal
                    if (this.content.id === 'editor-content') {
                        const lineNumbers = document.querySelector('.line-numbers');
                        if (lineNumbers) {
                            lineNumbers.scrollTop = this.content.scrollTop;
                        }
                    }
                }
                
                updateScrollbar() {
                    const contentHeight = this.content.scrollHeight;
                    const containerHeight = this.content.clientHeight;
                    
                    if (contentHeight <= containerHeight) {
                        this.scrollbar.style.display = 'none';
                        return;
                    }
                    
                    this.scrollbar.style.display = 'block';
                    
                    const thumbRatio = containerHeight / contentHeight;
                    const minThumbHeight = 30;
                    const thumbHeight = Math.max(minThumbHeight, thumbRatio * this.scrollbar.offsetHeight);
                    
                    this.thumb.style.height = thumbHeight + 'px';
                    this.updateThumbPosition();
                }
                
                updateThumbPosition() {
                    const contentHeight = this.content.scrollHeight;
                    const containerHeight = this.content.clientHeight;
                    const scrollTop = this.content.scrollTop;
                    const trackHeight = this.scrollbar.offsetHeight;
                    const thumbHeight = this.thumb.offsetHeight;
                    
                    const scrollRatio = scrollTop / (contentHeight - containerHeight);
                    const thumbTop = scrollRatio * (trackHeight - thumbHeight);
                    
                    this.thumb.style.top = thumbTop + 'px';
                }
            }
            
            // Initialize custom scrollbars
            const initScrollbars = () => {
                // Editor scrollbar
                const editorContainer = document.querySelector('.scroll-container');
                const editorContent = document.getElementById('editor-content');
                const editorScrollbar = document.getElementById('editor-scrollbar');
                const editorThumb = document.getElementById('editor-thumb');
                
                console.log('Editor elements:', { editorContainer, editorContent, editorScrollbar, editorThumb });
                
                if (editorContainer && editorContent && editorScrollbar && editorThumb) {
                    console.log('Creating editor scrollbar');
                    new CustomScrollbar(editorContainer, editorContent, editorScrollbar, editorThumb);
                }
                
                // Terminal scrollbar
                const terminalContainer = document.querySelector('.terminal-content .scroll-container');
                const terminalContent = document.getElementById('terminal-output');
                const terminalScrollbar = document.getElementById('terminal-scrollbar');
                const terminalThumb = document.getElementById('terminal-thumb');
                
                console.log('Terminal elements:', { terminalContainer, terminalContent, terminalScrollbar, terminalThumb });
                
                if (terminalContainer && terminalContent && terminalScrollbar && terminalThumb) {
                    console.log('Creating terminal scrollbar');
                    new CustomScrollbar(terminalContainer, terminalContent, terminalScrollbar, terminalThumb);
                }
            };

            // Function to update line numbers for current content
            function updateLineNumbers() {
                const editorContent = document.getElementById('editor-content');
                const content = editorContent.innerHTML;
                
                // Count actual rendered lines by creating a temporary element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                tempDiv.style.cssText = 'position: absolute; left: -9999px; top: -9999px; width: auto; height: auto; white-space: pre-wrap; font-family: Monaco, monospace; font-size: 14px; line-height: 1.5;';
                document.body.appendChild(tempDiv);
                
                // Get the actual height and calculate lines
                const lineHeight = parseInt(window.getComputedStyle(tempDiv).lineHeight);
                const totalHeight = tempDiv.offsetHeight;
                const lines = Math.max(1, Math.ceil(totalHeight / lineHeight));
                
                document.body.removeChild(tempDiv);
                
                // Update line numbers
                const lineNumbers = document.querySelector('.line-numbers');
                lineNumbers.innerHTML = '';
                for(let i = 1; i <= lines; i++) {
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'line-number';
                    lineDiv.textContent = i;
                    lineNumbers.appendChild(lineDiv);
                }
            }

            // Initialize
            document.addEventListener('DOMContentLoaded', () => {
                // Update line numbers for the default README content
                updateLineNumbers();
                
                // Focus terminal input
                terminalInput.focus();
                
                // Initialize custom scrollbars with longer delay to ensure DOM is ready
                setTimeout(() => {
                    console.log('Initializing scrollbars...');
                    initScrollbars();
                }, 500);
            });
        </script>
        
    </body>

</html>
